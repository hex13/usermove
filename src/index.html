<div style="height:300px;border:1px solid black"></div>
<div id="text" style="height:40; padding: 5px">abc</div>
<div id="text2" style="height:40; padding: 20px">abc</div>
<canvas id="app" width="1000" height="1000"></canvas>
<script>
    window.mode = 'draw';
    const ids = [];
    const label = document.getElementById('text');
    const label2 = document.getElementById('text2');
    function updateLabel(ids) {
        // label.innerText = Object.entries(ids).map(entry => entry[0] + "(" + entry[1] + ")").join(', ');
    }
    function interpolate(from, to, cb) {
        const distX = to.x - from.x;
        const distY = to.y - from.y;
        const dist = Math.hypot(distX, distY);
        const stepX = distX / dist;
        const stepY = distY / dist; 
        let x = from.x;
        let y = from.y;
        for (let a = 0; a < dist; a += 1) {
            cb({x, y});
            x += stepX;
            y += stepY;
        }
    }

    class Controller {
        constructor(el, opts = {}) {
            this.el = el;
            this.handlers = {};
            this.opts = opts;
            this.pointers = {};
        }
        init() {
            this.on('touchmove', e => {
                e.domEvent.preventDefault();
            });
            this.on('pointerdown', e => {
                this.pointers[e.domEvent.pointerId] = {start: e, last: e, isDown: true};
                updateLabel(this.pointers);
            });
            this.on('pointermove', e => {
                const pointerInfo = this.pointers[e.domEvent.pointerId];
                const pointerCount = Object.keys(this.pointers).length;
                pointerInfo.current = e;
                if (!pointerInfo.isDown) return;

                if (pointerCount == 1) {
                    interpolate(pointerInfo.last, e, interpolated => {
                        const delta = {
                            x: interpolated.x - pointerInfo.start.x,
                            y: interpolated.y - pointerInfo.start.y,
                        };
                        delta.angle = Math.atan2(delta.y, delta.x);
                        delta.distance = Math.hypot(delta.x, delta.y);
                        this.dispatch({ ...interpolated, type: 'usermove:drag', start: {...pointerInfo.start}, delta, isPrimary: e.isPrimary});
                    });
                } else if (pointerCount == 2) {
                    const [a, b] = Object.values(this.pointers);

                    const originalDistance = Math.hypot(a.start.x - b.start.x, a.start.y - b.start.y);
                    const currentDistance = Math.hypot(a.current.x - b.current.x, a.current.y - b.current.y);

                    const originalRotation = Math.atan2(a.start.y - b.start.y, a.start.x - b.start.x); 
                    const currentRotation = Math.atan2(a.current.y - b.current.y, a.current.x - b.current.x); 

                    this.dispatch({type: 'usermove:gesture', distance: currentDistance - originalDistance, rotation: currentRotation - originalRotation})
                }
                pointerInfo.last = e;
            });
            this.on('pointerup', e => {
                delete this.pointers[e.domEvent.pointerId];
                updateLabel(this.pointers);
            });
        }
        dispatch(e) {
            if (Object.hasOwn(this.handlers, e.type)) {
                this.handlers[e.type].forEach(handler => handler(e));
            }
        }
        mapEvent(e) {
            const boundingRect = this.el.getBoundingClientRect();
            const x = e.clientX - boundingRect.x;
            const y = e.clientY - boundingRect.y;
            const transformedEvent = { type: e.type, x, y, down: this.down, domEvent: e, start: { ...this.start}, isPrimary: e.isPrimary };
            if (this.opts.transformEvent) this.opts.transformEvent(transformedEvent);
            return transformedEvent;
        }
        on(eventName, handler) {
            if (!this.handlers[eventName]) {
                this.handlers[eventName] = [];
                this.el.addEventListener(eventName, e => {
                    this.dispatch(this.mapEvent(e));
                });
            }
            this.handlers[eventName].push(handler);
        }

    }

    const canvas = document.getElementById('app');
    const ctx = canvas.getContext('2d');

    function render() {
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    render();

    const controller = new Controller(canvas, {
        transformEvent(e) {
            const factor = 1;
            e.x = Math.floor(e.x / factor) * factor;
            e.y = Math.floor(e.y / factor) * factor;
        }
    });

    controller.init();

    controller.on('pointerdown', e => {
        if (!e.isPrimary) return;
        ctx.fillStyle = 'red';
        ctx.fillRect(e.x, e.y, 6, 6);
    });
    controller.on('click', e => {
        console.log("click 2")
    });


    controller.on('usermove:drag', e => {
        // if (!e.isPrimary) return;
        if (window.mode == 'draw') {
            ctx.fillStyle = 'yellow';
            ctx.fillRect(e.x, e.y, 2, 2);
        } else if (window.mode == 'move') {
            const delta = e.delta;
            ctx.fillStyle = 'red';
            ctx.fillRect(e.start.x + Math.cos(delta.angle) * delta.distance, e.start.y + Math.sin(delta.angle) * delta.distance, 2, 2);

            console.log("DIST", delta.distance)
        }
    });

    controller.on('usermove:gesture', e => {
        label2.innerText = e.distance.toFixed(2) + ", ROT  " + e.rotation.toFixed(2);
    });

</script>