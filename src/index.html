<div style="height:600px;border:1px solid black"></div>
<canvas id="app" width="1000" height="1000"></canvas>
<script>
    window.mode = 'draw';
    function interpolate(from, to, cb) {
        const distX = to.x - from.x;
        const distY = to.y - from.y;
        const dist = Math.hypot(distX, distY);
        const stepX = distX / dist;
        const stepY = distY / dist; 
        let x = from.x;
        let y = from.y;
        for (let a = 0; a < dist; a += 1) {
            cb({x, y});
            x += stepX;
            y += stepY;
        }
    }

    class Controller {
        constructor(el, opts = {}) {
            this.el = el;
            this.start = {x: 0, y: 0};
            this.last = null;
            this.handlers = {};
            this.opts = opts;
        }
        init() {
            this.on('touchmove', e => {
                e.domEvent.preventDefault();
            });
            this.on('pointerdown', e => {
                this.down = true;
                this.start = e;
                this.last = e;
            });
            this.on('pointermove', e => {
                if (!this.down) return;
                interpolate(this.last, e, e => {
                    const delta = {
                        x: e.x - this.start.x,
                        y: e.y - this.start.y,
                    };
                    delta.angle = Math.atan2(delta.y, delta.x);
                    delta.distance = Math.hypot(delta.x, delta.y);
                    this.dispatch({ ...e, type: 'usermove:drag', start: {...this.start}, delta});
                });
                this.last = e;
            });
            this.on('pointerup', e => {
                this.down = false;

            });
        }
        dispatch(e) {
            if (Object.hasOwn(this.handlers, e.type)) {
                this.handlers[e.type].forEach(handler => handler(e));
            }
        }
        mapEvent(e) {
            const boundingRect = this.el.getBoundingClientRect();
            const x = e.clientX - boundingRect.x;
            const y = e.clientY - boundingRect.y;
            const transformedEvent = { type: e.type, x, y, down: this.down, domEvent: e, start: { ...this.start} };
            if (this.opts.transformEvent) this.opts.transformEvent(transformedEvent);
            return transformedEvent;
        }
        on(eventName, handler) {
            if (!this.handlers[eventName]) {
                this.handlers[eventName] = [];
                this.el.addEventListener(eventName, e => {
                    this.dispatch(this.mapEvent(e));
                });
            }
            this.handlers[eventName].push(handler);
        }

    }

    const canvas = document.getElementById('app');
    const ctx = canvas.getContext('2d');

    function render() {
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    render();

    const controller = new Controller(canvas, {
        transformEvent(e) {
            const factor = 1;
            e.x = Math.floor(e.x / factor) * factor;
            e.y = Math.floor(e.y / factor) * factor;
        }
    });

    controller.init();

    controller.on('pointerdown', e => {
        ctx.fillStyle = 'red';
        ctx.fillRect(e.x, e.y, 6, 6);
    });
    controller.on('click', e => {
        console.log("click 2")
    });


    controller.on('usermove:drag', e => {
        if (window.mode == 'draw') {
            ctx.fillStyle = 'yellow';
            ctx.fillRect(e.x, e.y, 2, 2);
        } else if (window.mode == 'move') {
            const delta = e.delta;
            ctx.fillStyle = 'red';
            ctx.fillRect(e.start.x + Math.cos(delta.angle) * delta.distance, e.start.y + Math.sin(delta.angle) * delta.distance, 2, 2);


        }
    });

</script>